import { Feature } from 'ol';
import { Point, LineString } from 'ol/geom';
import { NetworkFeatureProperties } from '@/types/network';

/**
 * Robust helper to get ID from feature
 */
function getId(f: Feature): string {
    const id = f.getId() || f.get('id');
    return id ? String(id) : 'UNKNOWN_ID';
}

/**
 * Generates EPANET INP file content from network features
 */
export function generateINP(features: Feature[]): string {
    const lines: string[] = [];

    // Separate features by type
    const junctions = features.filter(f => f.get('type') === 'junction');
    const reservoirs = features.filter(f => f.get('type') === 'reservoir');
    const tanks = features.filter(f => f.get('type') === 'tank');
    const pipes = features.filter(f => f.get('type') === 'pipe');
    const pumps = features.filter(f => f.get('type') === 'pump');
    const valves = features.filter(f => f.get('type') === 'valve');

    // Header
    lines.push('[TITLE]');
    lines.push('EPANET Network generated by Water Network GIS');
    lines.push('');

    // [JUNCTIONS]
    if (junctions.length > 0) {
        lines.push('[JUNCTIONS]');
        lines.push(';ID              Elevation    Demand       Pattern');
        junctions.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.elevation || 0)} ${pad(props.demand || 0)}                ;`);
        });
        lines.push('');
    }

    // [RESERVOIRS]
    if (reservoirs.length > 0) {
        lines.push('[RESERVOIRS]');
        lines.push(';ID              Head         Pattern');
        reservoirs.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.head || 0)}                ;`);
        });
        lines.push('');
    }

    // [TANKS]
    if (tanks.length > 0) {
        lines.push('[TANKS]');
        lines.push(';ID              Elevation    InitLevel    MinLevel     MaxLevel     Diameter     MinVol       VolCurve');
        tanks.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.elevation || 0)} ${pad(props.initLevel || 0)} ${pad(props.minLevel || 0)} ${pad(props.maxLevel || 0)} ${pad(props.diameter || 0)} 0            ;`);
        });
        lines.push('');
    }

    // [PIPES]
    if (pipes.length > 0) {
        lines.push('[PIPES]');
        lines.push(';ID              Node1           Node2           Length       Diameter     Roughness    MinorLoss    Status');
        pipes.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(props.length || 0)} ${pad(props.diameter || 0)} ${pad(props.roughness || 100)} 0            ${props.status || 'Open'}`);
        });
        lines.push('');
    }

    // [PUMPS]
    if (pumps.length > 0) {
        lines.push('[PUMPS]');
        lines.push(';ID              Node1           Node2           Parameters');
        pumps.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} POWER ${props.power || 50}`);
        });
        lines.push('');
    }

    // [VALVES]
    if (valves.length > 0) {
        lines.push('[VALVES]');
        lines.push(';ID              Node1           Node2           Diameter     Type         Setting      MinorLoss');
        valves.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(props.diameter || 0)} ${props.valveType || 'PRV'} ${props.setting || 0} 0`);
        });
        lines.push('');
    }

    // [COORDINATES]
    lines.push('[COORDINATES]');
    lines.push(';Node            X-Coord          Y-Coord');
    [...junctions, ...reservoirs, ...tanks].forEach(f => {
        const geom = f.getGeometry() as Point;
        const coords = geom.getCoordinates();
        lines.push(`${pad(getId(f))} ${pad(coords[0])} ${pad(coords[1])}`);
    });
    lines.push('');

    // [VERTICES]
    lines.push('[VERTICES]');
    lines.push(';Link            X-Coord          Y-Coord');
    [...pipes].forEach(f => {
        const geom = f.getGeometry() as LineString;
        const coords = geom.getCoordinates();
        // Skip first and last (nodes)
        for (let i = 1; i < coords.length - 1; i++) {
            lines.push(`${pad(getId(f))} ${pad(coords[i][0])} ${pad(coords[i][1])}`);
        }
    });
    lines.push('');

    // End of file
    lines.push('[END]');

    return lines.join('\n');
}

/**
 * Helper to pad strings for columnar alignment
 */
function pad(val: any, width: number = 16): string {
    const str = String(val);
    if (str.length >= width) return str + ' ';
    return str.padEnd(width, ' ');
}