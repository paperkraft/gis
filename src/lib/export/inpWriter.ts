import { Feature } from 'ol';
import { Point, LineString } from 'ol/geom';
import { NetworkFeatureProperties, ProjectSettings, TimePattern, PumpCurve, NetworkControl } from '@/types/network';
import { useNetworkStore } from '@/store/networkStore';


function getId(f: Feature): string {
    const id = f.getId() || f.get('id');
    return id ? String(id).trim() : 'UNKNOWN_ID';
}

function pad(val: any, width: number = 16): string {
    const str = String(val);
    if (str.length >= width) return str + ' ';
    return str.padEnd(width, ' ');
}

export function generateINP(
    features: Feature[],
    customSettings?: ProjectSettings,
    customPatterns?: TimePattern[],
    customCurves?: PumpCurve[],
    customControls?: NetworkControl[]
): string {
    const lines: string[] = [];

    // 1. Resolve Data Sources
    const store = useNetworkStore.getState();
    const settings = customSettings || store.settings;
    const patterns = customPatterns || store.patterns || [];
    const curves = customCurves || store.curves || [];
    const controls = customControls || store.controls || [];

    // Ensure Pattern 1 exists (Default)
    const hasPattern1 = patterns.some(p => p.id === "1");
    const safePatterns = [...patterns];
    if (!hasPattern1) {
        safePatterns.push({ id: "1", description: "Default", multipliers: Array(24).fill(1.0) });
    }

    // Filter Features
    const junctions = features.filter(f => f.get('type') === 'junction');
    const reservoirs = features.filter(f => f.get('type') === 'reservoir');
    const tanks = features.filter(f => f.get('type') === 'tank');
    const pipes = features.filter(f => f.get('type') === 'pipe');
    const pumps = features.filter(f => f.get('type') === 'pump');
    const valves = features.filter(f => f.get('type') === 'valve');

    const allIds = new Set(features.map(getId));

    // --- 1. HEADER ---
    lines.push('[TITLE]');
    lines.push(settings.title || 'EPANET Network generated by Water Network GIS');
    lines.push('');

    // --- 2. OPTIONS ---
    lines.push('[OPTIONS]');
    lines.push(`Units              ${settings.units}`);
    lines.push(`Headloss           ${settings.headloss}`);
    lines.push(`Specific Gravity   ${settings.specificGravity}`);
    lines.push(`Viscosity          ${settings.viscosity}`);
    lines.push(`Trials             ${settings.trials}`);
    lines.push(`Accuracy           ${settings.accuracy}`);
    lines.push('CHECKFREQ          2');
    lines.push('MAXCHECK           10');
    lines.push('DAMPLIMIT          0');
    lines.push('UNBALANCED         Continue 10');
    lines.push('PATTERN            1');
    lines.push('');

    // --- 3. TIMES ---
    lines.push('[TIMES]');
    lines.push('Duration           24:00');
    lines.push('Hydraulic Timestep 1:00');
    lines.push('Pattern Timestep   1:00');
    lines.push('Report Timestep    1:00');
    lines.push('Report Start       0:00');
    lines.push('Start Time         0:00');
    lines.push('Statistic          None');
    lines.push('');

    // --- 4. PATTERNS ---
    lines.push('[PATTERNS]');
    lines.push(';ID   Multipliers');
    safePatterns.forEach(p => {
        const mults = [...p.multipliers];
        while (mults.length < 24) mults.push(1.0);
        const row1 = mults.slice(0, 12).map(v => v.toFixed(2)).join(' ');
        const row2 = mults.slice(12, 24).map(v => v.toFixed(2)).join(' ');
        lines.push(`${p.id}     ${row1}`);
        lines.push(`${p.id}     ${row2}`);
    });
    lines.push('');

    // --- 5. CURVES ---
    if (curves.length > 0) {
        lines.push('[CURVES]');
        lines.push(';ID   X-Value  Y-Value');
        curves.forEach(c => {
            c.points.forEach(pt => {
                lines.push(`${c.id}   ${pt.x}   ${pt.y}`);
            });
            lines.push('');
        });
        lines.push('');
    }

    // --- 6. NETWORK DATA (Must come BEFORE Controls) ---

    if (junctions.length > 0) {
        lines.push('[JUNCTIONS]');
        lines.push(';ID              Elevation    Demand       Pattern');
        junctions.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const pat = hasPattern1 ? "1" : "";
            lines.push(`${pad(getId(f))} ${pad(props.elevation || 0)} ${pad(props.demand || 0)}                ${pat}   ;`);
        });
        lines.push('');
    }

    if (reservoirs.length > 0) {
        lines.push('[RESERVOIRS]');
        lines.push(';ID              Head         Pattern');
        reservoirs.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.head || 0)}                ;`);
        });
        lines.push('');
    }

    if (tanks.length > 0) {
        lines.push('[TANKS]');
        lines.push(';ID              Elevation    InitLevel    MinLevel     MaxLevel     Diameter     MinVol       VolCurve');
        tanks.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.elevation || 0)} ${pad(props.initLevel || 0)} ${pad(props.minLevel || 0)} ${pad(props.maxLevel || 0)} ${pad(props.diameter || 0)} 0            ;`);
        });
        lines.push('');
    }

    if (pipes.length > 0) {
        lines.push('[PIPES]');
        lines.push(';ID              Node1           Node2           Length       Diameter     Roughness    MinorLoss    Status');
        pipes.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(props.length || 0)} ${pad(props.diameter || 0)} ${pad(props.roughness || 100)} 0            ${props.status || 'Open'}`);
        });
        lines.push('');
    }

    if (pumps.length > 0) {
        lines.push('[PUMPS]');
        lines.push(';ID              Node1           Node2           Parameters');
        pumps.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} POWER ${props.power || 50}`);
        });
        lines.push('');
    }

    if (valves.length > 0) {
        lines.push('[VALVES]');
        lines.push(';ID              Node1           Node2           Diameter     Type         Setting      MinorLoss');
        valves.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(props.diameter || 0)} ${props.valveType || 'PRV'} ${props.setting || 0} 0`);
        });
        lines.push('');
    }

    // --- 7. CONTROLS (MOVED HERE: AFTER COMPONENTS) ---
    if (controls.length > 0) {
        const validControls = controls.filter(c => {
            if (!c.linkId || !allIds.has(c.linkId)) return false;
            if (['LOW LEVEL', 'HI LEVEL'].includes(c.type)) {
                if (!c.nodeId || !allIds.has(c.nodeId)) return false;
            }
            return true;
        });

        if (validControls.length > 0) {
            lines.push('[CONTROLS]');
            validControls.forEach(c => {
                let line = '';
                // Sanitize IDs (Trim)
                const linkId = c.linkId.trim();
                const nodeId = c.nodeId ? c.nodeId.trim() : '';

                if (c.type === 'TIMER') {
                    // LINK <ID> <STATUS> AT TIME <VALUE>
                    line = `LINK ${linkId} ${c.status} AT TIME ${c.value}`;
                } else {
                    // LINK <ID> <STATUS> IF NODE <ID> <CONDITION> <VALUE>
                    const condition = c.type === 'LOW LEVEL' ? 'BELOW' : 'ABOVE';
                    line = `LINK ${linkId} ${c.status} IF NODE ${nodeId} ${condition} ${c.value}`;
                }
                lines.push(line);
            });
            lines.push('');
        }
    }

    // --- 8. VISUALS ---
    lines.push('[COORDINATES]');
    lines.push(';Node            X-Coord          Y-Coord');
    [...junctions, ...reservoirs, ...tanks].forEach(f => {
        const geom = f.getGeometry() as Point;
        const coords = geom.getCoordinates();
        lines.push(`${pad(getId(f))} ${pad(coords[0])} ${pad(coords[1])}`);
    });
    lines.push('');

    lines.push('[VERTICES]');
    lines.push(';Link            X-Coord          Y-Coord');
    [...pipes].forEach(f => {
        const geom = f.getGeometry() as LineString;
        const coords = geom.getCoordinates();
        for (let i = 1; i < coords.length - 1; i++) {
            lines.push(`${pad(getId(f))} ${pad(coords[i][0])} ${pad(coords[i][1])}`);
        }
    });
    lines.push('');

    lines.push('[END]');

    return lines.join('\n');
}